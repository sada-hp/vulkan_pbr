#version 460
#include "volumetric.glsl"

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

void main()
{
    vec2 size = imageSize(outImage).xy;
    ivec2 Texel = ivec2(2, 1) * ivec2(gl_GlobalInvocationID.xy);
    Texel.x += gl_GlobalInvocationID.y % 2 == 0 ? int(In.Order % 2 == 1) : int(In.Order % 2 == 0);

    vec2 ScreenUV = (0.5 + vec2(Texel)) / size;
    vec4 ScreenNDC = vec4(2.0 * ScreenUV - 1.0, 0.0, 1.0);
    vec4 ScreenView = ubo.ProjectionMatrixInverse * ScreenNDC;
    vec4 ScreenWorld = vec4(ubo.ViewMatrixInverse * ScreenView);
    ScreenWorld /= ScreenWorld.w;

    vec3 RayOrigin = vec3(ubo.CameraPositionFP64.xyz);
    vec3 SphereCenter = vec3(0.0, 0.0, 0.0);
    outScattering = vec4(0.0, 0.0, 0.0, 1.0);

    RayMarch Ray;
    Ray.Direction = normalize(ScreenWorld.xyz);
    
    vec4 OldPosition = vec4(uboOld.ViewProjectionMatrix * ScreenWorld);
    OldPosition /= OldPosition.w;
    OldPosition.xy = saturateAngle(OldPosition.xy) * 0.5 + 0.5;
    float inDepth = texture(depthImage, OldPosition.xy).r;
    vec4 WorldPosition = vec4(ubo.ViewMatrixInverse * ubo.ProjectionMatrixInverse * vec4(ScreenNDC.xy, inDepth, 1.0));
    vec3 inWorld = WorldPosition.xyz /= WorldPosition.w;

    Hits.Ground = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Rg);
    Hits.Ground = Hits.Ground == 0 ? distance(inWorld, RayOrigin) : min(distance(inWorld, RayOrigin), Hits.Ground);
    Hits.TopCloud = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Params.TopBound);
    Hits.BottomCloud = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Params.BottomBound);

    Hits.Camera = length(RayOrigin);
    float muHoriz = sqrt(1.0 - pow(Rg / Hits.Camera, 2.0));
    float horizon = dot(RayOrigin, Ray.Direction) / Hits.Camera + muHoriz;

    if (horizon > 0 && (Hits.Ground == 0 || Hits.Ground > Hits.BottomCloud))
    {
        Ray.End = RayOrigin + Ray.Direction * Hits.BottomCloud;

        float t = Hits.Ground == 0 ? Hits.TopCloud : min(Hits.TopCloud, Hits.Ground);
        Ray.Start = RayOrigin + Ray.Direction * t;

        MarchToCloud(Ray, distance(Ray.Start, Ray.End));
    }

    imageStore(outImage, Texel, outScattering);
}