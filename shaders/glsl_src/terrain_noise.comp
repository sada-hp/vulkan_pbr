#version 460
#include "ubo.glsl"
#include "constants.glsl"
#include "common.glsl"
#include "noise.glsl"

#define HEX_COMPUTE
#include "hextiling.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Vertex
{
    vec4 Position;
    vec4 World;
    vec4 UV;
};

struct TerrainLayer
{
    float Ea;
    float Es;
    float Ec;
    int Octaves;
    float Sharpness;
    int Op;
    float Frequency;
    float Offset;
};

layout (set = 1, binding = 0, rgba32f) uniform writeonly image2DArray terrainImage;
layout (std140, set = 1, binding = 1) readonly buffer TerrainLayersBuffer
{
    layout(offset = 0) int Count;
    layout(offset = 4) float TileScale;
    layout(offset = 16) TerrainLayer at[];
} Layers;

layout (set = 1, binding = 2) uniform sampler2DArray terrainImageOld;
layout (std140, set = 1, binding = 3) buffer TerrainReferenceBuffer
{
	Vertex at[];
} vertices;
layout (std140, set = 1, binding = 4) readonly buffer TerrainReferenceOld
{
	Vertex at[];
} verticesOld;

layout (constant_id = 2) const uint VertexCount = 0;
layout (constant_id = 3) const float Scale = 0;
layout (constant_id = 4) const float MinHeight = 0;
layout (constant_id = 5) const float MaxHeight = 0;
layout (constant_id = 6) const uint Seed = 0;
layout (constant_id = 7) const float deltaS = 0;

vec2 terrain_fbm(vec3 n, vec2 uv, int l)
{
    float fbm = 0.0;
    float Ampltude = 1.0;
    float GainA = 0.5;
    float GainF = 2.0;
    float freq = Layers.at[l].Frequency;

    float AltitudeF = Ampltude;
    float SlopeF = Ampltude;

    float river_network = 0.0;

    vec2 Gp = vec2(0.0);
    for (int i = 0; i < Layers.at[l].Octaves; i++)
    {
        float Np = 0.0;
        vec2 DNp = vec2(0.0);
        vec2 DNp2 = vec2(0.0);
        perlind(uv, freq, Np, DNp, DNp2);
        Np = saturateAngle((Layers.at[l].Offset + Np));

        float nb = abs(Np);
        float nr = 1.0 - nb;
        Np = Layers.at[l].Sharpness >= 0 ? mix(Np, nr, Layers.at[l].Sharpness) : mix(Np, nb, abs(Layers.at[l].Sharpness));

        float gi = mix( GainA, GainA * (1.0 / (1.0 + abs( min(0.0, 0.5 * (DNp2.x + DNp2.y)) ))), Layers.at[l].Ec );
        Gp = Gp + DNp * Layers.at[l].Es;
        SlopeF = 1.0 / (1.0 + dot(Gp, Gp));
        AltitudeF *= mix(gi, gi * max(0.0, Np), Layers.at[l].Ea);
        freq *= GainF;

        fbm += SlopeF * AltitudeF * Np;
        river_network += SlopeF * AltitudeF * abs(Np);
    }

    river_network = saturate(pow(river_network, 1.0 / 1.5));
    river_network = saturate(river_network - 0.5) * 2.0;
    river_network = saturate(river_network);

    return vec2(fbm, river_network);
}

float sample_perlin_sphere(vec3 Normal, float freq)
{
    return clamp(perlin(Normal.xz, freq) * perlin(Normal.xy, freq) * perlin(Normal.yz, freq), -1.0, 1.0);
}

void main()
{
    NOISE_SEED = Seed;

    if (NOISE_SEED != 0 && gl_GlobalInvocationID.x < VertexCount)
    {
        Vertex vertex = vertices.at[gl_GlobalInvocationID.x];
        Vertex oldVertex = verticesOld.at[gl_GlobalInvocationID.x];

        int Level = int(vertex.Position.y);
        float adjustScale = Scale * exp2(max(Level, deltaS));

        dvec3 Camera1 = ubo.WorldUp.xyz;
        dvec3 Center1 = round(RoundToIncrement(Camera1 * Rg, adjustScale));

        vec4 Val = vec4(0.0);
        ivec3 Texel = ivec3(round(vertex.UV.xy * (imageSize(terrainImage).xy - 1)), Level);
        dmat3 Orientation1 = GetTerrainOrientation(Camera1);
        vec3 ObjectPosition = round(vec3(Orientation1 * vec3(vertex.Position.x, 0.0, vertex.Position.z) + Center1));
        vec3 Normal = vec3(normalize(ObjectPosition));

        float halfSurfaceRadius = Rg + 0.5 * (MaxHeight - MinHeight);
        vec3 commonSurface = halfSurfaceRadius * RoundToIncrement(halfSurfaceRadius * Normal, adjustScale);
        if (RoundToIncrement(halfSurfaceRadius * normalize(vertex.World.xyz), adjustScale) != commonSurface)
        {
            if (RoundToIncrement(halfSurfaceRadius * normalize(oldVertex.World.xyz), adjustScale) == commonSurface)
            {
                imageStore(terrainImage, Texel, texelFetch(terrainImageOld, Texel, 0));
                vertices.at[gl_GlobalInvocationID.x].World = verticesOld.at[gl_GlobalInvocationID.x].World;
            }
            else if (Layers.Count > 0)
            {
#if 1
                float pole = abs(dot(Normal, vec3(0, 1, 0)));
                vec2 uv1 = 0.5 + vec2(atan(Normal.z, Normal.x) * ONE_OVER_2PI, asin(Normal.y) * ONE_OVER_2PI);
                vec2 uv2 = 0.5 + vec2(atan(Normal.x, Normal.y) * ONE_OVER_2PI, asin(Normal.z) * ONE_OVER_2PI);
                float pole_w = pole > 0.9 ? 0.0 : (pole >= 0.8 ? 1.0 - ((pole - 0.8) / (0.9 - 0.8)) : 1.0);

                HexParams p1, p2;
                GetHexParams(Layers.TileScale * uv1, p1);
                GetHexParams(Layers.TileScale * uv2, p2);

                vec3 Lw = vec3(0.299, 0.587, 0.114);
                vec3 Dw = vec3(dot(vec3(1.0, 0.0, 0.0), Lw), dot(vec3(0.0, 1.0, 0.0), Lw), dot(vec3(0.0, 0.0, 1.0), Lw));

                Dw = mix(vec3(1.0), Dw, vec3(0.6));
                vec3 Ww1 = vec3(0.0), Ww2 = vec3(0.0);
                if (Layers.Count > 1)
                {
                    vec3 W1 = Dw * pow(vec3(p1.w1, p1.w2, p1.w3), vec3(7));
                    vec3 W2 = Dw * pow(vec3(p2.w1, p2.w2, p2.w3), vec3(7));
                    W1 /= (W1.x + W1.y + W1.z);
                    W2 /= (W2.x + W2.y + W2.z);
                    Ww1 = ProduceHexWeights(W1, p1.v1, p1.v2, p1.v3);
                    Ww2 = ProduceHexWeights(W2, p2.v1, p2.v2, p2.v3);
                }
                else
                {
                    Ww1 = vec3(1.0);
                    Ww2 = vec3(1.0);
                }
#endif

                vec2 T1 = vec2(0.0), T2 = vec2(0.0);
                for (int i = 0; i < min(Layers.Count, 3); i++)
                {
                    T1 += Ww1[i] * terrain_fbm(Normal, uv1, i);
                    T2 += Ww2[i] * terrain_fbm(Normal, uv2, i);
                }

                T1.x = smootherstep(0.0, 1.0, T1.x);
                T2.x = smootherstep(0.0, 1.0, T2.x);

                Val.xy = mix(T1, T2, 1.0 - pole_w);

                float h = Val.x;
                Val.xy = vec2(MinHeight + Val.x * (MaxHeight - MinHeight), Val.y);

                imageStore(terrainImage, Texel, Val);
                vertices.at[gl_GlobalInvocationID.x].World = vec4(Normal * (Rg + Val.x), h);
            }
        }
    }
    else if (gl_GlobalInvocationID.x < VertexCount)
    {
        Vertex vertex = vertices.at[gl_GlobalInvocationID.x];
        int Level = int(vertex.Position.y);

        imageStore(terrainImage, ivec3(round(vertex.UV.xy * (imageSize(terrainImage).xy - 1)), Level), vec4(MinHeight, 0.0, 0.0, 0.0));
    }
}
