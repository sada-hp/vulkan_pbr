#version 460
#include "volumetric.glsl"

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

void main()
{
    vec2 size = imageSize(outImage).xy;
    ivec2 Texel = ivec2(2, 1) * ivec2(gl_GlobalInvocationID.xy);
    Texel.x += gl_GlobalInvocationID.y % 2 == 0 ? int(In.Order % 2 == 1) : int(In.Order % 2 == 0);

    vec2 ScreenUV = (0.5 + vec2(Texel)) / size;
    vec4 ScreenNDC = vec4(2.0 * ScreenUV - 1.0, 0.0, 1.0);
    vec4 ScreenWorld = vec4(ubo.ViewProjectionMatrixInverse * ScreenNDC);

    vec4 OldPosition = vec4(uboOld.ViewProjectionMatrix * ScreenWorld);
    OldPosition.xy = saturateAngle(OldPosition.xy / OldPosition.w) * 0.5 + 0.5;
    float inDepth = texture(depthImage, OldPosition.xy).r;
    vec4 WorldPosition = vec4(ubo.ViewProjectionMatrixInverse * vec4(ScreenNDC.xy, inDepth, 1.0));
    vec3 inWorld = WorldPosition.xyz / WorldPosition.w;

    vec3 RayOrigin = vec3(ubo.CameraPositionFP64.xyz);
    vec3 SphereCenter = vec3(0.0, 0.0, 0.0);
    outScattering = vec4(0.0, 0.0, 0.0, 1.0);

    RayMarch Ray;
    Ray.Direction = normalize(ScreenWorld.xyz);

    Hits.Ground = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Rg);
    Hits.Ground = Hits.Ground == 0 ? distance(inWorld, RayOrigin) : min(distance(inWorld, RayOrigin), Hits.Ground);
    Hits.TopCloud = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Params.TopBound);
    Hits.BottomCloud = SphereMinDistance(RayOrigin, Ray.Direction, SphereCenter, Params.BottomBound);
    Hits.Camera = float(ubo.CameraRadius);

    float muHoriz = sqrt(1.0 - pow(Rg / Hits.Camera, 2.0));
    float horizon = dot(RayOrigin, Ray.Direction) / Hits.Camera + muHoriz;
    if (horizon >= 0)
    {
        Ray.End = RayOrigin;
        Ray.Start = RayOrigin + Ray.Direction * min(Hits.TopCloud, Hits.Ground);
    }
    else
    {
        Ray.End = RayOrigin;
        Ray.Start = RayOrigin + Ray.Direction * min(Hits.BottomCloud, Hits.Ground);
    }

    MarchToCloud(Ray, distance(Ray.Start, Ray.End));

    if (outScattering.a != 1.0)
    {
        vec4 clip1 = vec4(ubo.ViewProjectionMatrix * vec4(Ray.FirstHit, 1.0));
        vec4 clip2 = vec4(ubo.ViewProjectionMatrix * vec4(Ray.LastHit, 1.0));
        float outDepth = max(clip1.z / clip1.w, clip2.z / clip2.w);

        outScattering = outDepth > inDepth ? mix(outScattering, texelFetch(oldImage, Texel, 0), 0.15) : vec4(0.0, 0.0, 0.0, 1.0);
    }

    imageStore(outImage, Texel, outScattering);
}